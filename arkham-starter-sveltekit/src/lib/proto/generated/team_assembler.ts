// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "team_assembler.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * @generated from protobuf message TeamAssemblerProto
 */
export interface TeamAssemblerProto {
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.InputDeck input_decks_1 = 1;
	 */
	inputDecks1: TeamAssemblerProto_InputDeck[]
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.InputDeck input_decks_2 = 2;
	 */
	inputDecks2: TeamAssemblerProto_InputDeck[]
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.InputDeck input_decks_3 = 3;
	 */
	inputDecks3: TeamAssemblerProto_InputDeck[]
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.InputDeck input_decks_4 = 4;
	 */
	inputDecks4: TeamAssemblerProto_InputDeck[]
	/**
	 * @generated from protobuf field: repeated string current_team = 5;
	 */
	currentTeam: string[]
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.PickedAssembly picked_assembly = 6;
	 */
	pickedAssembly: TeamAssemblerProto_PickedAssembly[]
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.UserPatch user_patches = 7;
	 */
	userPatches: TeamAssemblerProto_UserPatch[]
	/**
	 * @generated from protobuf field: bool advanced = 8;
	 */
	advanced: boolean
}
/**
 * @generated from protobuf message TeamAssemblerProto.InputDeck
 */
export interface TeamAssemblerProto_InputDeck {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string
	/**
	 * @generated from protobuf field: bool published = 2;
	 */
	published: boolean
	/**
	 * @generated from protobuf field: string comment = 3;
	 */
	comment: string
}
/**
 * @generated from protobuf message TeamAssemblerProto.PickedAssembly
 */
export interface TeamAssemblerProto_PickedAssembly {
	/**
	 * @generated from protobuf field: repeated TeamAssemblerProto.PickedAssembly.Deck decks = 1;
	 */
	decks: TeamAssemblerProto_PickedAssembly_Deck[]
}
/**
 * @generated from protobuf message TeamAssemblerProto.PickedAssembly.Deck
 */
export interface TeamAssemblerProto_PickedAssembly_Deck {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string
	/**
	 * @generated from protobuf field: string rename = 2;
	 */
	rename: string
	/**
	 * @generated from protobuf field: repeated string patch_adds = 3;
	 */
	patchAdds: string[]
	/**
	 * @generated from protobuf field: repeated string patch_removes = 4;
	 */
	patchRemoves: string[]
	/**
	 * @generated from protobuf field: string comments = 5;
	 */
	comments: string
}
/**
 * @generated from protobuf message TeamAssemblerProto.UserPatch
 */
export interface TeamAssemblerProto_UserPatch {
	/**
	 * @generated from protobuf field: int32 id = 1;
	 */
	id: number
	/**
	 * @generated from protobuf field: string name = 2;
	 */
	name: string
	/**
	 * @generated from protobuf field: string url = 3;
	 */
	url: string
}
// @generated message type with reflection information, may provide speed optimized methods
class TeamAssemblerProto$Type extends MessageType<TeamAssemblerProto> {
	constructor() {
		super('TeamAssemblerProto', [
			{
				no: 1,
				name: 'input_decks_1',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_InputDeck,
			},
			{
				no: 2,
				name: 'input_decks_2',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_InputDeck,
			},
			{
				no: 3,
				name: 'input_decks_3',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_InputDeck,
			},
			{
				no: 4,
				name: 'input_decks_4',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_InputDeck,
			},
			{
				no: 5,
				name: 'current_team',
				kind: 'scalar',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 6,
				name: 'picked_assembly',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_PickedAssembly,
			},
			{
				no: 7,
				name: 'user_patches',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_UserPatch,
			},
			{ no: 8, name: 'advanced', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
		])
	}
	create(value?: PartialMessage<TeamAssemblerProto>): TeamAssemblerProto {
		const message = {
			inputDecks1: [],
			inputDecks2: [],
			inputDecks3: [],
			inputDecks4: [],
			currentTeam: [],
			pickedAssembly: [],
			userPatches: [],
			advanced: false,
		}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
		if (value !== undefined) reflectionMergePartial<TeamAssemblerProto>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: TeamAssemblerProto,
	): TeamAssemblerProto {
		const message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* repeated TeamAssemblerProto.InputDeck input_decks_1 */ 1:
					message.inputDecks1.push(
						TeamAssemblerProto_InputDeck.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				case /* repeated TeamAssemblerProto.InputDeck input_decks_2 */ 2:
					message.inputDecks2.push(
						TeamAssemblerProto_InputDeck.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				case /* repeated TeamAssemblerProto.InputDeck input_decks_3 */ 3:
					message.inputDecks3.push(
						TeamAssemblerProto_InputDeck.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				case /* repeated TeamAssemblerProto.InputDeck input_decks_4 */ 4:
					message.inputDecks4.push(
						TeamAssemblerProto_InputDeck.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				case /* repeated string current_team */ 5:
					message.currentTeam.push(reader.string())
					break
				case /* repeated TeamAssemblerProto.PickedAssembly picked_assembly */ 6:
					message.pickedAssembly.push(
						TeamAssemblerProto_PickedAssembly.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				case /* repeated TeamAssemblerProto.UserPatch user_patches */ 7:
					message.userPatches.push(
						TeamAssemblerProto_UserPatch.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				case /* bool advanced */ 8:
					message.advanced = reader.bool()
					break
				default:
					const u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					const d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: TeamAssemblerProto,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated TeamAssemblerProto.InputDeck input_decks_1 = 1; */
		for (let i = 0; i < message.inputDecks1.length; i++)
			TeamAssemblerProto_InputDeck.internalBinaryWrite(
				message.inputDecks1[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* repeated TeamAssemblerProto.InputDeck input_decks_2 = 2; */
		for (let i = 0; i < message.inputDecks2.length; i++)
			TeamAssemblerProto_InputDeck.internalBinaryWrite(
				message.inputDecks2[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* repeated TeamAssemblerProto.InputDeck input_decks_3 = 3; */
		for (let i = 0; i < message.inputDecks3.length; i++)
			TeamAssemblerProto_InputDeck.internalBinaryWrite(
				message.inputDecks3[i],
				writer.tag(3, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* repeated TeamAssemblerProto.InputDeck input_decks_4 = 4; */
		for (let i = 0; i < message.inputDecks4.length; i++)
			TeamAssemblerProto_InputDeck.internalBinaryWrite(
				message.inputDecks4[i],
				writer.tag(4, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* repeated string current_team = 5; */
		for (let i = 0; i < message.currentTeam.length; i++)
			writer.tag(5, WireType.LengthDelimited).string(message.currentTeam[i])
		/* repeated TeamAssemblerProto.PickedAssembly picked_assembly = 6; */
		for (let i = 0; i < message.pickedAssembly.length; i++)
			TeamAssemblerProto_PickedAssembly.internalBinaryWrite(
				message.pickedAssembly[i],
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* repeated TeamAssemblerProto.UserPatch user_patches = 7; */
		for (let i = 0; i < message.userPatches.length; i++)
			TeamAssemblerProto_UserPatch.internalBinaryWrite(
				message.userPatches[i],
				writer.tag(7, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* bool advanced = 8; */
		if (message.advanced !== false) writer.tag(8, WireType.Varint).bool(message.advanced)
		const u = options.writeUnknownFields
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message TeamAssemblerProto
 */
export const TeamAssemblerProto = new TeamAssemblerProto$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TeamAssemblerProto_InputDeck$Type extends MessageType<TeamAssemblerProto_InputDeck> {
	constructor() {
		super('TeamAssemblerProto.InputDeck', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'published', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 3, name: 'comment', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(value?: PartialMessage<TeamAssemblerProto_InputDeck>): TeamAssemblerProto_InputDeck {
		const message = { id: '', published: false, comment: '' }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
		if (value !== undefined)
			reflectionMergePartial<TeamAssemblerProto_InputDeck>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: TeamAssemblerProto_InputDeck,
	): TeamAssemblerProto_InputDeck {
		const message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string()
					break
				case /* bool published */ 2:
					message.published = reader.bool()
					break
				case /* string comment */ 3:
					message.comment = reader.string()
					break
				default:
					const u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					const d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: TeamAssemblerProto_InputDeck,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id)
		/* bool published = 2; */
		if (message.published !== false) writer.tag(2, WireType.Varint).bool(message.published)
		/* string comment = 3; */
		if (message.comment !== '') writer.tag(3, WireType.LengthDelimited).string(message.comment)
		const u = options.writeUnknownFields
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message TeamAssemblerProto.InputDeck
 */
export const TeamAssemblerProto_InputDeck = new TeamAssemblerProto_InputDeck$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TeamAssemblerProto_PickedAssembly$Type extends MessageType<TeamAssemblerProto_PickedAssembly> {
	constructor() {
		super('TeamAssemblerProto.PickedAssembly', [
			{
				no: 1,
				name: 'decks',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => TeamAssemblerProto_PickedAssembly_Deck,
			},
		])
	}
	create(
		value?: PartialMessage<TeamAssemblerProto_PickedAssembly>,
	): TeamAssemblerProto_PickedAssembly {
		const message = { decks: [] }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
		if (value !== undefined)
			reflectionMergePartial<TeamAssemblerProto_PickedAssembly>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: TeamAssemblerProto_PickedAssembly,
	): TeamAssemblerProto_PickedAssembly {
		const message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* repeated TeamAssemblerProto.PickedAssembly.Deck decks */ 1:
					message.decks.push(
						TeamAssemblerProto_PickedAssembly_Deck.internalBinaryRead(
							reader,
							reader.uint32(),
							options,
						),
					)
					break
				default:
					const u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					const d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: TeamAssemblerProto_PickedAssembly,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* repeated TeamAssemblerProto.PickedAssembly.Deck decks = 1; */
		for (let i = 0; i < message.decks.length; i++)
			TeamAssemblerProto_PickedAssembly_Deck.internalBinaryWrite(
				message.decks[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		const u = options.writeUnknownFields
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message TeamAssemblerProto.PickedAssembly
 */
export const TeamAssemblerProto_PickedAssembly = new TeamAssemblerProto_PickedAssembly$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TeamAssemblerProto_PickedAssembly_Deck$Type extends MessageType<TeamAssemblerProto_PickedAssembly_Deck> {
	constructor() {
		super('TeamAssemblerProto.PickedAssembly.Deck', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'rename', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 3,
				name: 'patch_adds',
				kind: 'scalar',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/,
			},
			{
				no: 4,
				name: 'patch_removes',
				kind: 'scalar',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/,
			},
			{ no: 5, name: 'comments', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(
		value?: PartialMessage<TeamAssemblerProto_PickedAssembly_Deck>,
	): TeamAssemblerProto_PickedAssembly_Deck {
		const message = { id: '', rename: '', patchAdds: [], patchRemoves: [], comments: '' }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
		if (value !== undefined)
			reflectionMergePartial<TeamAssemblerProto_PickedAssembly_Deck>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: TeamAssemblerProto_PickedAssembly_Deck,
	): TeamAssemblerProto_PickedAssembly_Deck {
		const message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string()
					break
				case /* string rename */ 2:
					message.rename = reader.string()
					break
				case /* repeated string patch_adds */ 3:
					message.patchAdds.push(reader.string())
					break
				case /* repeated string patch_removes */ 4:
					message.patchRemoves.push(reader.string())
					break
				case /* string comments */ 5:
					message.comments = reader.string()
					break
				default:
					const u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					const d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: TeamAssemblerProto_PickedAssembly_Deck,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id)
		/* string rename = 2; */
		if (message.rename !== '') writer.tag(2, WireType.LengthDelimited).string(message.rename)
		/* repeated string patch_adds = 3; */
		for (let i = 0; i < message.patchAdds.length; i++)
			writer.tag(3, WireType.LengthDelimited).string(message.patchAdds[i])
		/* repeated string patch_removes = 4; */
		for (let i = 0; i < message.patchRemoves.length; i++)
			writer.tag(4, WireType.LengthDelimited).string(message.patchRemoves[i])
		/* string comments = 5; */
		if (message.comments !== '') writer.tag(5, WireType.LengthDelimited).string(message.comments)
		const u = options.writeUnknownFields
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message TeamAssemblerProto.PickedAssembly.Deck
 */
export const TeamAssemblerProto_PickedAssembly_Deck =
	new TeamAssemblerProto_PickedAssembly_Deck$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TeamAssemblerProto_UserPatch$Type extends MessageType<TeamAssemblerProto_UserPatch> {
	constructor() {
		super('TeamAssemblerProto.UserPatch', [
			{ no: 1, name: 'id', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(value?: PartialMessage<TeamAssemblerProto_UserPatch>): TeamAssemblerProto_UserPatch {
		const message = { id: 0, name: '', url: '' }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
		if (value !== undefined)
			reflectionMergePartial<TeamAssemblerProto_UserPatch>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: TeamAssemblerProto_UserPatch,
	): TeamAssemblerProto_UserPatch {
		const message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int32 id */ 1:
					message.id = reader.int32()
					break
				case /* string name */ 2:
					message.name = reader.string()
					break
				case /* string url */ 3:
					message.url = reader.string()
					break
				default:
					const u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					const d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: TeamAssemblerProto_UserPatch,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* int32 id = 1; */
		if (message.id !== 0) writer.tag(1, WireType.Varint).int32(message.id)
		/* string name = 2; */
		if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name)
		/* string url = 3; */
		if (message.url !== '') writer.tag(3, WireType.LengthDelimited).string(message.url)
		const u = options.writeUnknownFields
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message TeamAssemblerProto.UserPatch
 */
export const TeamAssemblerProto_UserPatch = new TeamAssemblerProto_UserPatch$Type()
